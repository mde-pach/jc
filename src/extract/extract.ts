/**
 * Core extraction entry point — thin resolver that delegates to the pipeline.
 *
 * Resolves the extractor from config (default: react-docgen-typescript),
 * then runs the extraction pipeline. Also hosts registry generation and
 * output writing.
 */

import { existsSync, mkdirSync, writeFileSync } from 'node:fs'
import { resolve } from 'node:path'
import { applyPathAlias } from '../lib/utils.js'
import type { ExtractionResult, JcConfig, JcMeta } from '../types.js'
import type { Extractor } from './extractor.js'
import { runPipeline } from './pipeline.js'
import { createReactDocgenExtractor } from './react-docgen-extractor.js'

// ── Re-exports ────────────────────────────────────────────────

export { applyPathAlias } from '../lib/utils.js'
export type { Extractor, ExtractorContext, ExtractorOutput } from './extractor.js'
// Utility functions used by tests and consumers
export {
  cleanValues,
  createPropFilter,
  detectAcceptsChildren,
  detectComponentKind,
  extractValues,
  isBooleanEnum,
  isTypeName,
  simplifyType,
} from './react-docgen-extractor.js'

// ── Extractor resolution ──────────────────────────────────────

function resolveExtractor(config: JcConfig): Extractor {
  const ext = config.extractor
  if (!ext || ext === 'react-docgen') return createReactDocgenExtractor()
  return ext
}

// ── Main extraction ───────────────────────────────────────────

export function extract(projectRoot: string, config: JcConfig): ExtractionResult {
  return runPipeline(projectRoot, config, resolveExtractor(config))
}

// ── Registry generation ───────────────────────────────────────

export function generateRegistry(meta: JcMeta, config: JcConfig): string {
  const pathAlias = config.pathAlias ?? { '@/': 'src/' }
  const seen = new Set<string>()
  const entries: Array<{ name: string; importPath: string; isDefault: boolean }> = []

  for (const comp of meta.components) {
    if (seen.has(comp.displayName)) continue
    seen.add(comp.displayName)
    const importPath = applyPathAlias(comp.filePath, pathAlias).replace(/\.tsx$/, '')
    entries.push({
      name: comp.displayName,
      importPath,
      isDefault: comp.exportType === 'default',
    })
  }

  const lines: string[] = [
    '/* Auto-generated by jc extract — DO NOT EDIT */',
    '/* eslint-disable */',
    '',
    "import type { ComponentType } from 'react'",
    '',
    'export const registry: Record<string, () => Promise<ComponentType<any>>> = {',
  ]

  for (const { name, importPath, isDefault } of entries) {
    if (isDefault) {
      // Default exports: try .default first, fall back to named export
      lines.push(
        `  '${name}': () => import('${importPath}').then(m => (m as any).default ?? (m as any).${name}),`,
      )
    } else {
      lines.push(`  '${name}': () => import('${importPath}').then(m => (m as any).${name}),`)
    }
  }

  lines.push('}', '')
  return lines.join('\n')
}

// ── Write output ──────────────────────────────────────────────

export function writeOutput(projectRoot: string, config: JcConfig, meta: JcMeta): void {
  const outputDir = resolve(projectRoot, config.outputDir)
  if (!existsSync(outputDir)) {
    mkdirSync(outputDir, { recursive: true })
  }

  writeFileSync(resolve(outputDir, 'meta.json'), JSON.stringify(meta, null, 2))
  writeFileSync(resolve(outputDir, 'registry.ts'), generateRegistry(meta, config))

  console.log(`[jc] Output → ${config.outputDir}/`)
  console.log(`[jc]   meta.json (${meta.components.length} components)`)
  console.log('[jc]   registry.ts')

  for (const comp of meta.components) {
    const propCount = Object.keys(comp.props).length
    const propNames = Object.keys(comp.props).join(', ')
    console.log(`  ${comp.displayName} (${propCount} props${propNames ? `: ${propNames}` : ''})`)
  }
}
